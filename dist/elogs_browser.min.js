(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){(function(global){const Circuit=require("./modules/circuit");const Const=require("./modules/const").constants;const PublicConst={MachineTruthTable:Const.MachineTruthTable,Port:Const.Port,Value:Const.Value};global.ELoGS={circuit:Circuit,constants:PublicConst}}).call(this,typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{"./modules/circuit":2,"./modules/const":4}],2:[function(require,module,exports){const stateProvider=require("./state");const Connection=require("./connection");const SimpleMachine=require("./machine");const Const=require("./const").constants;class Circuit{constructor(){this.machines={};this.connectionGraph={};this.stateHistory=new stateProvider.StateHistory;this.currentState=new stateProvider.State([])}_getMachines(){return this.machines}_getMachineById(machineId){return this.machines[machineId]}_getMachineByName(machineName){for(const machineId in this.machines){if(this.machines[machineId].getName()===machineName){return this.machines[machineId]}}return null}addMachine(name,machineTruthTable){if(this._getMachineByName(name)!==null){throw new Error(Const.ErrorMessage.DUPLICATE_MACHINE(name))}const machine=new SimpleMachine(name,machineTruthTable);this._addMachine(machine)}_addMachine(machine){this.machines[machine.getId()]=machine;this.connectionGraph[machine.getId()]={inputs:[],outputs:[]};this._invalidateState()}removeMachine(machineId){const machineToRemove=this._getMachineByName(machineId);if(this._getMachineByName(machineId)===null){throw new Error(Const.ErrorMessage.NON_EXISTENT_MACHINE(machineId))}this._removeMachine(machineToRemove)}_removeMachine(machine){delete this.machines[machine.getId()];delete this.connectionGraph[machine.getId()];this._invalidateState()}addConnection(outMachineId,outPort,inMachineId,inPort){const outMachine=this._getMachineByName(outMachineId);const inMachine=this._getMachineByName(inMachineId);if(outMachine===null){throw new Error(Const.ErrorMessage.NON_EXISTENT_MACHINE(outMachineId))}if(inMachine===null){throw new Error(Const.ErrorMessage.NON_EXISTENT_MACHINE(inMachineId))}if(outPort>=outMachine.getOutputDimension()){throw new Error(Const.ErrorMessage.PORT_OUT_OF_RANGE(true,outMachineId,outPort,outMachine.getOutputDimension()))}if(inPort>=inMachine.getInputDimension()){throw new Error(Const.ErrorMessage.PORT_OUT_OF_RANGE(false,inMachineId,inPort,inMachine.getInputDimension()))}const connection=new Connection(outMachine,outPort,inMachine,inPort);this._addConnection(connection)}_addConnection(connection){this.connectionGraph[connection.getOutMachine().getId()].outputs.push(connection.getConnectionToInput());this.connectionGraph[connection.getInMachine().getId()].inputs.push(connection.getConnectionToOutput());this._invalidateState()}_getConnection(outMachineId,outPort,inMachineId,inPort){const outMachine=this._getMachineByName(outMachineId);const inMachine=this._getMachineByName(inMachineId);if(outMachine===null||inMachine===null){return null}let connectionToInput=this._getConnectionToInput(this.connectionGraph[outMachine.getId()].outputs,inMachine,inPort);let connectionToOutput=this._getConnectionToOutput(this.connectionGraph[inMachine.getId()].inputs,outMachine,outPort);let connection=null;if(connectionToInput!==null&&connectionToOutput!==null){connection=new Connection(connectionToOutput.getOutMachine(),connectionToOutput.getOutPort(),connectionToInput.getInMachine(),connectionToInput.getInPort())}return connection}_getConnectionToInput(outputs,inMachine,inPort){for(const connectionToIn of outputs){if(connectionToIn.getInMachine()===inMachine&&connectionToIn.getInPort()===inPort){return connectionToIn}}return null}_getConnectionToOutput(inputs,outMachine,outPort){for(const connectionToOut of inputs){if(connectionToOut.getOutMachine()===outMachine&&connectionToOut.getOutPort()===outPort){return connectionToOut}}return null}removeConnection(outMachineId,outPort,inMachineId,inPort){const connection=this._getConnection(outMachineId,outPort,inMachineId,inPort);if(connection===null){throw Const.ErrorMessage.CONNECTION_DOESNT_EXIST(outMachineId,outPort,inMachineId,inPort)}this._removeConnection(connection)}_removeConnection(connection){const outputs=this.connectionGraph[connection.getOutMachine()].outputs;const connectionOutputIdx=outputs.indexOf(connection.getConnectionToInput());outputs.splice(connectionOutputIdx,1);const inputs=this.connectionGraph[connection.getInMachine()].inputs;const connectionInputIdx=inputs.indexOf(connection.getConnectionToOutput());inputs.splice(connectionInputIdx,1);this._invalidateState()}simulate(initialState){this._invalidateState();if(initialState){this.currentState=initialState.clone()}const inputMachines=this._findInputMachines();inputMachines.forEach(inMachine=>{this._simulateMachine(inMachine)});return this._getFinalState()}_simulateMachine(machine){let inputs=this._findAllMachineInputs(machine);if(inputs===Const.Value.UNDEFINED){let undefinedOutputs=new Array(this._getMachineById(machine).getOutputDimension());undefinedOutputs=undefinedOutputs.fill(Const.Value.UNDEFINED);this._updateState(machine,undefinedOutputs)}else{inputs=inputs.map(input=>input===Const.Value.UNDEFINED?Const.Value.LOW:input);const outputs=this._getMachineById(machine).calculateOutput(inputs);this._updateState(machine,outputs)}if(this.stateHistory.isStable()||this.stateHistory.isInCycle()){return}const machineOutConnections=this.connectionGraph[machine].outputs;for(const connection of machineOutConnections){const targetMachine=connection.getInMachine();this._simulateMachine(targetMachine.getId())}}_updateState(machine,outputs){this.currentState.setOutputs(machine,outputs);this.stateHistory.addState(this.currentState.clone())}_getFinalState(){return this.stateHistory.isEmpty()?this.currentState.clone():this.stateHistory.getLastState().clone()}_findAllMachineInputs(machine,searchTriggeringMachines=[]){if(searchTriggeringMachines.includes(String(machine))){return Const.Value.UNDEFINED}searchTriggeringMachines.push(String(machine));const inputs=[];const machineInConnections=this.connectionGraph[machine].inputs;for(const connection of machineInConnections){const sourcePort=connection.getOutPort();const sourceMachine=connection.getOutMachine();let sourceMachineInputs=this._findAllMachineInputs(sourceMachine.getId(),searchTriggeringMachines);if(sourceMachineInputs===Const.Value.UNDEFINED){inputs.push(Const.Value.UNDEFINED);continue}sourceMachineInputs=sourceMachineInputs.map(input=>input===Const.Value.UNDEFINED?Const.Value.LOW:input);const input=sourceMachine.getOutputOnPort(sourceMachineInputs,sourcePort);inputs.push(input)}return inputs}_findInputMachines(){return Object.keys(this._getMachines()).filter(machineId=>this._getMachineById(machineId).getInputDimension()===0)}_invalidateState(){this.stateHistory=new stateProvider.StateHistory;this.currentState=new stateProvider.State(this._getMachines())}}module.exports=Circuit},{"./connection":3,"./const":4,"./machine":5,"./state":6}],3:[function(require,module,exports){const Const=require("./const").constants;class Connection{constructor(outMachine,outPort,inMachine,inPort){this._throwIfConnectionInvalid(outMachine,outPort,inMachine,inPort);this.connectionToInput=new ConnectionToInput(inMachine,inPort);this.connectionToOutput=new ConnectionToOutput(outMachine,outPort)}_throwIfConnectionInvalid(outMachine,outPort,inMachine,inPort){if(!(outMachine instanceof Object)){throw new Error(Const.ErrorMessage.NOT_MACHINE(outMachine))}if(!(inMachine instanceof Object)){throw new Error(Const.ErrorMessage.NOT_MACHINE(inMachine))}if(typeof outPort!=="number"){throw new Error(Const.ErrorMessage.NOT_PORT(outPort))}if(typeof inPort!=="number"){throw new Error(Const.ErrorMessage.NOT_PORT(inPort))}}getOutMachine(){return this.connectionToOutput.getOutMachine()}getOutPort(){return this.connectionToOutput.getOutPort()}getInMachine(){return this.connectionToInput.getInMachine()}getInPort(){return this.connectionToInput.getInPort()}getConnectionToInput(){return this.connectionToInput}getConnectionToOutput(){return this.connectionToOutput}}class ConnectionToInput{constructor(inMachine,inPort){this.inMachine=inMachine;this.inPort=inPort}getInMachine(){return this.inMachine}getInPort(){return this.inPort}}class ConnectionToOutput{constructor(outMachine,outPort){this.outMachine=outMachine;this.outPort=outPort}getOutMachine(){return this.outMachine}getOutPort(){return this.outPort}}module.exports=Connection},{"./const":4}],4:[function(require,module,exports){const ErrorMessage={INVALID_MACHINE_NAME:name=>`Invalid machine name: ${name}`,MISSING_INPUT:"Machine has missing inputs",ABSTRACT_CLASS_INSTRANTIATION:"Abstract classes cannot be instantiated",STATE_HISTORY_EMPTY:"State history is empty",DUPLICATE_MACHINE:name=>`Machine already exists: ${name}`,CONNECTION_DOESNT_EXIST:(outMachineId,outPort,inMachineId,inPort)=>`Connection from machine ${outMachineId}, port ${outPort} to machine ${inMachineId}, port ${inPort} doesn't exist`,NON_EXISTENT_MACHINE:machineId=>`Machine doesn't exist: ${machineId}`,PORT_OUT_OF_RANGE:(isOutPort,machineId,port,machinePortDimension)=>`${isOutPort?"Output":"Input"} port ${port} is out of range in machine ${machineId}. Number of ${isOutPort?"Output":"Input"} ports in machine: ${machinePortDimension}.`,INVALID_TRUTH_TABLE:machineName=>`Truth table for machine ${machineName} is invalid`,NOT_MACHINE:inMachine=>`${inMachine} is not a machine`,NOT_PORT:port=>`${port} is not a port`,NOT_STATE:state=>`${state} is not a state`,MACHINE_NOT_IN_STATE:machine=>`${machine} not present in state`};const EMPTY_INPUTS=[];const Value={LOW:false,HIGH:true,UNDEFINED:undefined,DISCONNECTED:null};const MachineTruthTable={NOT:{0:[Value.HIGH],1:[Value.LOW]},AND:{"00":[Value.LOW],"01":[Value.LOW],10:[Value.LOW],11:[Value.HIGH]},NAND:{"00":[Value.HIGH],"01":[Value.HIGH],10:[Value.HIGH],11:[Value.LOW]},OR:{"00":[Value.LOW],"01":[Value.HIGH],10:[Value.HIGH],11:[Value.HIGH]},NOR:{"00":[Value.HIGH],"01":[Value.LOW],10:[Value.LOW],11:[Value.LOW]},XOR:{"00":[Value.LOW],"01":[Value.HIGH],10:[Value.HIGH],11:[Value.LOW]},ON:{"":[Value.HIGH]},OFF:{"":[Value.LOW]}};const Port={A:0,B:1,C:2,D:3,E:4,F:5,G:6,H:7};module.exports.constants={ErrorMessage:ErrorMessage,Value:Value,MachineTruthTable:MachineTruthTable,EMPTY_INPUTS:EMPTY_INPUTS,Port:Port};module.exports.initializer=(context=>{context.ErrorMessage=ErrorMessage;context.Value=Value;context.MachineTruthTable=MachineTruthTable;context.EMPTY_INPUTS=EMPTY_INPUTS;context.Port=Port})},{}],5:[function(require,module,exports){const Const=require("./const").constants;const truthTableValidator={validate:truthTable=>{if(!(truthTable instanceof Object)){return false}return truthTableValidator._validateInputs(Object.keys(truthTable))&&truthTableValidator._validateOutputs(Object.values(truthTable))},_validateInputs:inputs=>{if(inputs.length===0){return false}const inputLength=inputs[0].length;for(const input of inputs){if(!truthTableValidator._isValidInput(input,inputLength)){return false}}return inputs.length===Math.pow(2,inputLength)},_isValidInput:(input,inputLength)=>{return truthTableValidator._validInputRegExp.test(input)&&input.length===inputLength},_validateOutputs:outputs=>{if(outputs.length===0){return false}let outputLength;if(outputs[0]instanceof Array){outputLength=outputs[0].length}else{return false}for(const output of outputs){if(!truthTableValidator._isValidOutput(output,outputLength)){return false}}return true},_isValidOutput:(output,outputLength)=>{for(const value of output){if(!truthTableValidator._isValidValue(value)){return false}}return output instanceof Array&&output.length===outputLength},_isValidValue:value=>{let isValid=false;for(valueKey in Const.Value){if(Const.Value[valueKey]===value){isValid=true;break}}return isValid},_validInputRegExp:new RegExp("^[01]*$")};class AbstractMachine{static _generateMachineId(){AbstractMachine.currentId++;return AbstractMachine.currentId}constructor(){this.id=AbstractMachine._generateMachineId();this.hasAllInputs=false}getOutputDimension(){}getInputDimension(){}getId(){return this.toString()}toString(){return new String(this.id)}}AbstractMachine.currentId=0;class SimpleMachine extends AbstractMachine{constructor(name,truthTable){if(typeof name!=="string"||!SimpleMachine.nameRegExp.test(name)){throw new Error(Const.ErrorMessage.INVALID_MACHINE_NAME(name))}if(!truthTableValidator.validate(truthTable)){throw new Error(Const.ErrorMessage.INVALID_TRUTH_TABLE(name))}super();this.name=name;this.truthTable=truthTable}calculateOutput(inputs){inputs=inputs.map(input=>{let concatInput;if(input===Const.Value.LOW){concatInput="0"}if(input===Const.Value.HIGH){concatInput="1"}return concatInput});inputs=inputs.join("");return this.truthTable[inputs]}getOutputOnPort(inputs,port){return this.calculateOutput(inputs)[port]}getOutputDimension(){return Object.keys(this.truthTable).length>0?this.truthTable[Object.keys(this.truthTable)[0]].length:0}getInputDimension(){return Object.keys(this.truthTable).length>0?Object.keys(this.truthTable)[0].length:0}getName(){return this.name}getId(){return this.getName()}toString(){return this.getName()}}SimpleMachine.nameRegExp=new RegExp("^[a-zA-Z0-9][-_a-zA-Z0-9]*$");module.exports=SimpleMachine},{"./const":4}],6:[function(require,module,exports){const Const=require("./const").constants;class State{constructor(machines){this.state={};for(let machineId in machines){const outDim=machines[machineId].getOutputDimension();this.state[machineId]=new Array(outDim)}}getOutput(machine,port){if(this.state[machine]===undefined){throw new Error(Const.ErrorMessage.MACHINE_NOT_IN_STATE(machine))}if(port>=this.state[machine].length){throw new Error(Const.ErrorMessage.PORT_OUT_OF_RANGE(true,machine,port,this.state[machine].length))}return this.state[machine][port]}setOutput(machine,port,output){return this.state[machine][port]=output}getOutputs(machine){if(this.state[machine]===undefined){throw new Error(Const.ErrorMessage.MACHINE_NOT_IN_STATE(machine))}return this.state[machine]}setOutputs(machine,outputs){return this.state[machine]=outputs}compare(otherState){if(!(otherState instanceof State)){throw new Error(Const.ErrorMessage.NOT_STATE(otherState))}const thisStateMachines=Object.keys(this.state);const otherStateMachines=Object.keys(otherState.state);if(thisStateMachines.length!==otherStateMachines.length){return false}for(const machine of thisStateMachines){const thisStateMachineOutputs=this.state[machine];const otherStateMachineOutputs=otherState.state[machine];if(thisStateMachineOutputs.length!==otherStateMachineOutputs.length){return false}for(let i=0;i<thisStateMachineOutputs.length;i++){if(thisStateMachineOutputs[i]!==otherStateMachineOutputs[i]){return false}}}return true}clone(){const clone=new State({});for(const machine in this.state){clone.state[machine]=Array.from(this.state[machine])}return clone}toString(){let stateDescriptor="";for(const machine in this.state){stateDescriptor+=`${machine} output: ${JSON.stringify(this.state[machine])} \n`}return stateDescriptor}}class StateHistory{constructor(){this.states=[]}addState(state){if(!(state instanceof State)){throw new Error(Const.ErrorMessage.NOT_STATE(state))}this.states.push(state)}getLastState(){if(this.states.length>0){return this.states[this.states.length-1]}else{throw new Error(Const.ErrorMessage.STATE_HISTORY_EMPTY)}}isStable(){if(this.states.length>=2){const lastState=this.states[this.states.length-1];const lastLastState=this.states[this.states.length-2];return lastState.compare(lastLastState)}else{return false}}isInCycle(){for(let i=2;i<=Math.floor(this.states.length/2);i++){let hasCycle=true;const recentStates=this.states.slice().reverse().slice(0,i);const historyStates=this.states.slice().reverse().slice(i,2*i);for(let j=0;j<i;j++){if(!recentStates[j].compare(historyStates[j])){hasCycle=false;break}}if(hasCycle){return true}}return false}isEmpty(){return this.states.length===0}toString(){let stateDescriptor="";for(let i=0;i<this.states.length;i++){stateDescriptor+=`State ${i}: \n`;stateDescriptor+=this.states[i].toString()}return stateDescriptor}}module.exports={State:State,StateHistory:StateHistory}},{"./const":4}]},{},[1]);